
# IOI Upsolving Challenge

https://contest.yandex.com/ioi/total

Я решал их почти 2 года назад и уже не очень хорошо всё помню.

# 09-2

12 мая

### Медведь Миша

Можно сделать бинарный поиск по ответу: понятно, что дать фору медведю всегда можно. Когда мы проверяем очередное время, можно поддерживать текущие множества достижимых медведем и пчелами ячеек с помощью чего-то вроде двух параллельных bfs-ов. Работать такое будет за $O(n^2 \log n)$.

### Регионы

В ограничениях нам спалили важную идею: задачу можно просто решить в случае, если все регионы небольшие, а также в случае, если регионов немного. Обычно это означает, что решения можно объединить с помощью корневой эвристики.

Назовем крупными регионы те, у которых больше 500 представителей, а остальные будем называть мелкими. Обрабатывать запросы будем так:

* Крупный -> *: сделаем предподсчет для всех таких запросов, пройдясь dfs-ом по дереву и для каждой вершины из крупного региона добавив до 500 значений в прекальк
* Мелкий -> *: для каждого региона заранее составим массив tin-ов его вершин; теперь можно для каждой вершины мелкого региона сделать бинпоиск по этому массиву, чтобы узнать, сколько вершин она покрывает, сумма этих чисел будет являться ответом на запрос

Такое должно работать за $O(n \sqrt{n \log n})$, и TL такое позволяет.

### Коммивояжёр

Это на самом деле задача на подсчет динамики через ДО. Нужно моделировать события с конца, поддерживая (неявно) такую динамику: находимся здесь-то в такое-то время (по этому слою мы и будем пересчитывать), сколько денег можно отсюда заработать.

Подумайте, какой вид будет иметь эта функция, если зафиксировать время.

TODO

# 05-1

31 мая

### Сад

Тут вроде нужно насчитать динамику «какой оптимальный ответ, если нам нужно поставить ровно один участок на этом префиксном прямоугольнике», а дальше смерджить её. Но это не точно.

### Средняя последовательность

Понятно, что если зафиксировать какой-нибудь элемент последовательности, то остальные можно однозначно восстановить. Будем считывать среднюю последовательность и поддерживать множество возможных первых элементов, поочередно обрезая верхние и нижние границы:

```c++
int a = -inf, b = inf, _d = 0, d = 0, t;
for(int i = 0; i < n; i++){
    cin >> t;
    _d = d;
    d = 2*t - d;
    if (i % 2 == 0)
        b = min(b, (d-_d)/2);
    else
        a = max(a, (_d-d)/2);
}

cout << max(b - a + 1, 0ll);
```

### Польские горки

По сути от нас просят обрабатывать запросы «присвоить всем элементам с $l$ по $r$ значение $x$» и уметь находить (делать спуск) максимум префиксных сумм. Решается это с ДО с отложенными операциями. Конкретно, нам нужно хранить сумму на отрезке, максимум префиксных сумм и информацию, нужно ли проталкивать запрос дальше.

# 05-2

### Прямоугольник

Я не шарю, как её нормально решать. Я помню, что два года назад анализировал числа Гранди для состояний и придумал какую-то битовую магию на 30 строк, а в разборе какая-то индукция была. Расскажите, пожалуйста.
